# senior-developer
senior developver 101 no technical


Senior developer – no coding skills

Use sticky note – note the short cuts – use the shortcuts 
-	Ide – intellij idea, vs code

Googling – get best resources

Play courses 2x or 3x if you undestarnd it

How to learn

## Senior developer needs

*	Proficient - 
Writes high quality 
Aware of technologies and methodologies
Finds and solves bugs quickly and efficiently

*	Manages himself –
Prioritizes and handles taks

*	Professional
Brings value
Strives for excellence – continuous improving

*	Team player
Looks beyond his tasks
Selfless


### Excel

Understand -> solve -> implement -> test

Completing tasks
Solving bugs

#### Understanding the task – why is understanding the task importance ?

*	Having clear understanding
*	Specification document -> clear understanding of the task -> less bugs, minimize changes after coding begins, better time management. 
*	You understand it when you can explain it
*	System analyst -> 
  *	what does the user see ?
  *	how does each part behave ?
  *	what interaction is there with other components ?
  *	what are the edge cases, and how to handle them ?

thing of edge cases – help you the tests

document what you know

flow chart – use diagram or chart
edge cases – write document – scenario and handling columns

uml chart alternative 


#### Solving – what is the step to solving optimize

What is optimal solution

Why spend time on planning a solution ?

*	no reinventing the wheel – already there are optmal solution
*	write compatible code – naming conventions, project structure, 
*	no waste time on implementing sub-optimal solutions
*	not find later that solution doesn’t work 

example : use this plugin for table, because this is pros. It is simple to integrate. Have integrate to testing fast and simple.

What are the steps for reaching the optimal solution for a task ?

1 – define task technically – what are the scope(technical scops) and context
Technical scope – what arealdy exists ? what need to be done ?
If there are feature that you want to implement, then use it. If there is slightly different you need to refactor.
Context – 
*	parts of the system that interacts with your code – exception handling mechanism, locking mechanism. How to integrate.
*	Code you can learn from or use – read another codes.
*	Coding standards – naming conventiongs, file structure, etc etc.

2 – find optimal solution – 
*	What are some relevant solutions ? which solution is the optimal ? why ? – 
  *	Building from scratch
  *	Building from existing ones. Legacy code
  *	Which sorting, searching algorithms use. What kind of database schema
*	Comparing solutions, and pick the better solution.
  *	Criteria
    *	Cost
    *	Performance
    * Forward Compatibility
    *	Simplicity
    *	Security
    *	Completeness – handles all cases 
    *	Coding standards & conventions compatibility
    *	Etc.

*	Validate applicability – use PEOC (Proof of the concepts)minimum needed to handle it. Prototype. Is the chosen solution applicable ?

How to remember ?

*	Documenting – comments to the mock ups, 
*	Use algorithm/pseudo code – when there are complex logic
*	Write more Edge cases



#### Implementing the solution – good coding session

write code

before implementing

* be aware of all the task's details
* concentrate on the big picture
* the main flow is where you should start coding(solving big issues first and filling the minor issues later)

what is considered a good coding session ?
* concentrate solely on solving a specific issue
* clear image of what you're trying to accomplish

technical details missing, which you are uncertain

If you stop often to ask questions or assume things and tell yourseflt you'll check tehm later


where to start writing code ?

* the main flow, keep to do for details(wordings like messages, build specific ui )
* complete details later 


#### Testing – why , how and how much

do first test, 

flawless softwrae

why test ?
* what i did works perfectly
how to test ?
* QA - try to break things. change mind set.
* abuse your feature
* test mercilessly
* list of test cases 
how much to test ? 
* dedicated QA teams are an anti-pattern. testers should find nothing.Zero.Nada
* As much as it takes for you to be sure there aren't any bugs
when to test ?
* TDD - write the automated test before you write the actual code
* as soon as possible

#### Bugs

* know your toolbox - solving bugs - can save times. 
    * debugger
    * IDE

* Document
    * what you already tried - debug
    * prove bugs cause
    * where is the breaking the code
    * for Knowledge tranfer
    * confusion cause costs
    * what you need to documents :
    * what did you try, and what results did you get ?
    * what clues did you find ?
    * what do you plan on doing next?
    * everithing else that might help

* bug solving stages 
     
     * gather information - undestand the correct behavior
     * understand related functionality
     * find and understand the error message(logs, screen) if there is (read the error)
     * see for yourlself (the bug) (reproduce the bug)
     * find the exact point of failure (networking problem, amount of data problem) - narrow it down
     * read the code and black box test
 
* debugging prepartions
     * understand the flow of the code (stacktrace) - which class call which class, also for method or server
     * reprodce locally - start by seeing it break, then fix it
     * refactor to improve readbility, refactor to new function (not overdue it)

* Debug
     * Articulate (what you exactly knows)  
     * Doubt your assumptions (the problem can be in another place)
       * what did i assume to be working correctly and hence not check properly ?
       * could a problem there cause the symptoms i'm seeing ?
     * Every assumptions you validate makes you stand on more solid ground 
     * Every assumptions you invalidate changes your focus toward the real problem
     * Consider solving withous solving (instead debugging the library and fix, just change the library)    
     * Avoid changing code you don't undertand - sometimes, solving the problem will result in another problem
     * only change code you undestand

* Test
     * what you fixed works correctly
     * what did work correctly, still does (dependencies)  


good softwre - produces high quality softtware on time
* carpeter proverb - measure twice, cut once - spend more time on planning and less time on execution
      * always look for unclear issues, and make them clear.
      * always know where you are in the bigger picture.
      * always make sure what you know is available to you
* error can be costly

- miss feature, after production is pretty expensive.
- low quality is very expensive


### Learn
Set goals – learning techniques – build a plan

### Take the next step
Time management – code quality – the zone – stand out

### Conclusion

